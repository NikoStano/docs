---
title: "Get Next Line"
description: "Fonction de lecture ligne par ligne d'un fichier"
icon: "file-lines"
---

# ðŸ“„ Get Next Line

<img src="https://img.shields.io/badge/Score-125%2F100-success" alt="Score" />
<img src="https://img.shields.io/badge/Language-C-blue" alt="Language" />
<img src="https://img.shields.io/badge/Difficulty-Medium-orange" alt="Difficulty" />

## Introduction

**Get Next Line** (GNL) est un projet qui consiste Ã  crÃ©er une fonction capable de lire un fichier ligne par ligne, quelle que soit la taille du buffer. Ce projet introduit les concepts de variables statiques et de gestion optimisÃ©e de la mÃ©moire.

<Note>
Ce projet est essentiel pour comprendre la lecture de fichiers en C et sera rÃ©utilisÃ© dans de nombreux projets futurs, notamment dans les parseurs.
</Note>

## Prototype de la fonction

```c
char *get_next_line(int fd);
```

### ParamÃ¨tres

- **fd** : File descriptor du fichier Ã  lire

### Retour

- La ligne lue (incluant le `\n` si prÃ©sent)
- `NULL` si fin de fichier ou erreur

## Fonctionnement

<Steps>
  <Step title="Lecture par buffer">
    Lit le fichier par morceaux de taille BUFFER_SIZE
  </Step>
  
  <Step title="Stockage en variable statique">
    Conserve les donnÃ©es lues entre les appels de fonction
  </Step>
  
  <Step title="Extraction de ligne">
    Extrait une ligne complÃ¨te (jusqu'au `\n`) du buffer
  </Step>
  
  <Step title="Gestion du reste">
    Conserve les donnÃ©es restantes pour le prochain appel
  </Step>
</Steps>

## Compilation avec BUFFER_SIZE

Le BUFFER_SIZE est dÃ©fini Ã  la compilation et dÃ©termine le nombre d'octets lus Ã  chaque appel Ã  `read()`.

<Tabs>
  <Tab title="Petit buffer">
    ```bash
    # Buffer de 1 octet (test extrÃªme)
    gcc -Wall -Wextra -Werror -D BUFFER_SIZE=1 \
        get_next_line.c get_next_line_utils.c
    ```
  </Tab>
  
  <Tab title="Buffer standard">
    ```bash
    # Buffer de 42 octets
    gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 \
        get_next_line.c get_next_line_utils.c
    ```
  </Tab>
  
  <Tab title="Grand buffer">
    ```bash
    # Buffer de 4096 octets (1 page)
    gcc -Wall -Wextra -Werror -D BUFFER_SIZE=4096 \
        get_next_line.c get_next_line_utils.c
    ```
  </Tab>
</Tabs>

## Exemple d'utilisation

### Lecture d'un fichier simple

```c
#include "get_next_line.h"
#include 
#include 

int main(void)
{
    int fd;
    char *line;
    
    fd = open("test.txt", O_RDONLY);
    if (fd < 0)
        return (1);
    
    // Lecture ligne par ligne
    while ((line = get_next_line(fd)) != NULL)
    {
        printf("%s", line);
        free(line);
    }
    
    close(fd);
    return (0);
}
```

### Lecture de plusieurs fichiers simultanÃ©ment (Bonus)

```c
#include "get_next_line_bonus.h"
#include 
#include 

int main(void)
{
    int fd1, fd2, fd3;
    char *line;
    
    fd1 = open("file1.txt", O_RDONLY);
    fd2 = open("file2.txt", O_RDONLY);
    fd3 = open("file3.txt", O_RDONLY);
    
    // Lit alternativement dans les 3 fichiers
    line = get_next_line(fd1);
    printf("File1: %s", line);
    free(line);
    
    line = get_next_line(fd2);
    printf("File2: %s", line);
    free(line);
    
    line = get_next_line(fd3);
    printf("File3: %s", line);
    free(line);
    
    // Continue avec fd1...
    line = get_next_line(fd1);
    printf("File1: %s", line);
    free(line);
    
    close(fd1);
    close(fd2);
    close(fd3);
    return (0);
}
```

### Lecture depuis stdin

```c
#include "get_next_line.h"
#include 

int main(void)
{
    char *line;
    
    printf("Entrez du texte (Ctrl+D pour terminer):\n");
    
    // Lecture depuis l'entrÃ©e standard (fd = 0)
    while ((line = get_next_line(0)) != NULL)
    {
        printf("Vous avez Ã©crit: %s", line);
        free(line);
    }
    
    return (0);
}
```

## Concepts clÃ©s

### Variables statiques

<Accordion title="Qu'est-ce qu'une variable statique ?">
  Une variable statique conserve sa valeur entre les appels de fonction.
  
  ```c
  char *get_next_line(int fd)
  {
      static char *saved;  // ConservÃ©e entre les appels
      
      if (!saved)
          saved = malloc(BUFFER_SIZE + 1);
      // ...
  }
  ```
  
  <Warning>
  La variable statique doit Ãªtre libÃ©rÃ©e avant de retourner NULL Ã  la fin du fichier !
  </Warning>
</Accordion>

### Gestion de la mÃ©moire

<AccordionGroup>
  <Accordion title="Allocation dynamique">
    ```c
    // Allouer un buffer de lecture
    char *buffer = malloc(sizeof(char) * (BUFFER_SIZE + 1));
    if (!buffer)
        return (NULL);
    
    // Toujours initialiser
    buffer[BUFFER_SIZE] = '\0';
    ```
  </Accordion>
  
  <Accordion title="LibÃ©ration mÃ©moire">
    ```c
    // LibÃ©rer et mettre Ã  NULL
    free(buffer);
    buffer = NULL;
    
    // Pour la variable statique en fin de fichier
    if (saved)
    {
        free(saved);
        saved = NULL;
    }
    return (NULL);
    ```
  </Accordion>
  
  <Accordion title="RÃ©allocation">
    ```c
    // Agrandir le buffer si nÃ©cessaire
    char *new_buffer = ft_strjoin(saved, buffer);
    free(saved);
    saved = new_buffer;
    ```
  </Accordion>
</AccordionGroup>

### File Descriptors

<Accordion title="Comprendre les file descriptors">
  - **0** : stdin (entrÃ©e standard)
  - **1** : stdout (sortie standard)  
  - **2** : stderr (sortie d'erreur)
  - **3+** : fichiers ouverts par le programme
  
  ```c
  // Ouvrir un fichier
  int fd = open("file.txt", O_RDONLY);
  
  // VÃ©rifier l'ouverture
  if (fd < 0)
      return (error);
  
  // Lire avec get_next_line
  char *line = get_next_line(fd);
  
  // Toujours fermer !
  close(fd);
  ```
</Accordion>

## Partie Bonus

<Warning>
Le bonus consiste Ã  gÃ©rer plusieurs file descriptors simultanÃ©ment avec une seule variable statique de type tableau.
</Warning>

### Gestion multi-fd

```c
#define MAX_FD 1024

char *get_next_line(int fd)
{
    static char *saved[MAX_FD];  // Un slot par fd possible
    
    if (fd < 0 || fd >= MAX_FD)
        return (NULL);
    
    // Utilise saved[fd] pour ce fichier spÃ©cifique
    // ...
}
```

### Exemple bonus

```c
// Ouvrir 3 fichiers
int fd1 = open("file1.txt", O_RDONLY);
int fd2 = open("file2.txt", O_RDONLY);
int fd3 = open("file3.txt", O_RDONLY);

// Lire dans n'importe quel ordre
get_next_line(fd1);  // Ligne 1 de file1
get_next_line(fd3);  // Ligne 1 de file3
get_next_line(fd1);  // Ligne 2 de file1
get_next_line(fd2);  // Ligne 1 de file2
get_next_line(fd3);  // Ligne 2 de file3
```

## Cas limites Ã  gÃ©rer

<AccordionGroup>
  <Accordion title="Fichier vide">
    ```c
    // Doit retourner NULL immÃ©diatement
    int fd = open("empty.txt", O_RDONLY);
    char *line = get_next_line(fd);  // NULL
    ```
  </Accordion>
  
  <Accordion title="Ligne sans \n Ã  la fin">
    ```c
    // DerniÃ¨re ligne sans retour Ã  la ligne
    // Doit quand mÃªme retourner la ligne
    "DerniÃ¨re ligne sans \\n"  // Doit Ãªtre retournÃ©
    ```
  </Accordion>
  
  <Accordion title="Fichier avec uniquement \n">
    ```c
    // Fichier contenant : "\n\n\n"
    line1 = get_next_line(fd);  // "\n"
    line2 = get_next_line(fd);  // "\n"
    line3 = get_next_line(fd);  // "\n"
    line4 = get_next_line(fd);  // NULL
    ```
  </Accordion>
  
  <Accordion title="Buffer size = 1">
    ```c
    // Doit fonctionner mÃªme avec un buffer d'1 octet
    gcc -D BUFFER_SIZE=1 ...
    ```
  </Accordion>
  
  <Accordion title="TrÃ¨s grande ligne">
    ```c
    // Ligne de 10000 caractÃ¨res
    // Doit Ãªtre gÃ©rÃ©e correctement
    ```
  </Accordion>
</AccordionGroup>

## Algorithme gÃ©nÃ©ral

```c
1. Si fd invalide ou erreur â†’ retourner NULL

2. Lire BUFFER_SIZE octets du fichier
   - Si erreur de lecture â†’ libÃ©rer et retourner NULL
   - Si fin de fichier (0 octets lus) â†’ traiter le reste et retourner NULL

3. Ajouter les octets lus au buffer statique

4. Chercher '\n' dans le buffer statique
   - Si trouvÃ© :
     â€¢ Extraire la ligne (jusqu'au '\n' inclus)
     â€¢ Garder le reste dans le buffer statique
     â€¢ Retourner la ligne
   
   - Si non trouvÃ© :
     â€¢ Retourner Ã  l'Ã©tape 2 (lire plus de donnÃ©es)

5. Ã€ la fin du fichier :
   - Si buffer statique non vide â†’ retourner ce qu'il reste
   - Sinon â†’ retourner NULL
```

## Structure recommandÃ©e

```
get_next_line/
â”œâ”€â”€ get_next_line.c        # Fonction principale
â”œâ”€â”€ get_next_line_utils.c  # Fonctions utilitaires
â”œâ”€â”€ get_next_line.h        # Header
â”œâ”€â”€ get_next_line_bonus.c  # Version bonus (multi-fd)
â”œâ”€â”€ get_next_line_bonus.h  # Header bonus
â””â”€â”€ test/
    â”œâ”€â”€ main.c             # Tests
    â””â”€â”€ files/             # Fichiers de test
```

## Fonctions utilitaires

<Tabs>
  <Tab title="strlen">
    ```c
    size_t  ft_strlen(const char *s)
    {
        size_t i = 0;
        while (s[i])
            i++;
        return (i);
    }
    ```
  </Tab>
  
  <Tab title="strchr">
    ```c
    char    *ft_strchr(const char *s, int c)
    {
        while (*s)
        {
            if (*s == (char)c)
                return ((char *)s);
            s++;
        }
        if (c == '\0')
            return ((char *)s);
        return (NULL);
    }
    ```
  </Tab>
  
  <Tab title="strjoin">
    ```c
    char    *ft_strjoin(char const *s1, char const *s2)
    {
        char    *result;
        size_t  i, j;
        
        if (!s1 || !s2)
            return (NULL);
        result = malloc(ft_strlen(s1) + ft_strlen(s2) + 1);
        if (!result)
            return (NULL);
        i = 0;
        while (s1[i])
        {
            result[i] = s1[i];
            i++;
        }
        j = 0;
        while (s2[j])
            result[i++] = s2[j++];
        result[i] = '\0';
        return (result);
    }
    ```
  </Tab>
</Tabs>

## Tests recommandÃ©s

<CodeGroup>
```bash Testeur Tripouille
git clone https://github.com/Tripouille/gnlTester.git
cd gnlTester
make m  # Tests mandatory
make b  # Tests bonus
```

```bash Tests manuels
# CrÃ©er des fichiers de test
echo -e "Line 1\nLine 2\nLine 3" > test.txt
echo -n "No newline at end" > test2.txt
echo -e "\n\n\n" > test3.txt

# Compiler et tester
gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 \
    get_next_line.c get_next_line_utils.c main.c
./a.out
```

```bash Valgrind
# VÃ©rifier les fuites mÃ©moire
valgrind --leak-check=full --show-leak-kinds=all ./a.out
```
</CodeGroup>

## PiÃ¨ges Ã  Ã©viter

<Warning>
**Fuite mÃ©moire sur la variable statique** : Pensez Ã  libÃ©rer saved avant de retourner NULL en fin de fichier.
</Warning>

<Warning>
**Oubli du \\0** : Toujours terminer vos chaÃ®nes avec un caractÃ¨re nul.
</Warning>

<Warning>
**Mauvaise gestion du reste** : Le reste aprÃ¨s un \\n doit Ãªtre conservÃ© pour le prochain appel.
</Warning>

<Warning>
**Buffer non initialisÃ©** : Toujours initialiser vos buffers avant utilisation.
</Warning>

## Conseils

<Tip>
**Testez avec diffÃ©rents BUFFER_SIZE** : 1, 42, 1024, 10000000. Votre fonction doit fonctionner dans tous les cas.
</Tip>

<Tip>
**Dessinez le flux de donnÃ©es** : Faites des schÃ©mas pour visualiser comment les donnÃ©es circulent entre les appels.
</Tip>

<Tip>
**Utilisez des testeurs** : Les testeurs de la communautÃ© couvrent de nombreux cas limites.
</Tip>

## Ressources

<CardGroup cols={2}>
  <Card title="man read" icon="book">
    ```bash
    man 2 read
    ```
    Documentation de la fonction read()
  </Card>
  
  <Card title="man open" icon="book">
    ```bash
    man 2 open
    ```
    Documentation de la fonction open()
  </Card>
  
  <Card title="Static variables" icon="code" href="https://www.geeksforgeeks.org/static-variables-in-c/">
    Comprendre les variables statiques en C
  </Card>
  
  <Card title="File I/O" icon="file" href="https://www.gnu.org/software/libc/manual/html_node/Low_002dLevel-I_002fO.html">
    Guide complet sur les I/O en C
  </Card>
</CardGroup>

## Conclusion

Get Next Line est un projet fondamental qui vous apprendra :
- La gestion de la mÃ©moire dynamique
- Les variables statiques
- La manipulation de fichiers
- L'optimisation des lectures

<Check>
Cette fonction sera rÃ©utilisÃ©e dans presque tous vos projets futurs nÃ©cessitant la lecture de fichiers !
</Check>