---
title: "Minitalk"
description: "Communication client-serveur avec signaux Unix"
icon: "satellite-dish"
---

# ğŸ“¡ Minitalk

<img src="https://img.shields.io/badge/Score-125%2F100-success" alt="Score" />
<img src="https://img.shields.io/badge/Language-C-blue" alt="Language" />
<img src="https://img.shields.io/badge/Type-Unix%20Signals-green" alt="Type" />

## Introduction

**Minitalk** est un projet qui implÃ©mente un systÃ¨me de communication entre un client et un serveur en utilisant uniquement les signaux Unix SIGUSR1 et SIGUSR2.

<Card
  title="Voir sur GitHub"
  icon="github"
  href="https://github.com/NikoStano/minitalk"
>
  AccÃ©der au repository GitHub
</Card>

<Note>
Ce projet vous apprend les bases de la communication inter-processus (IPC) et la manipulation des signaux Unix.
</Note>

## Objectifs pÃ©dagogiques

<Steps>
  <Step title="Signaux Unix">
    Comprendre et utiliser les signaux SIGUSR1 et SIGUSR2
  </Step>
  
  <Step title="Communication bit par bit">
    Transmettre des donnÃ©es en envoyant des bits individuellement
  </Step>
  
  <Step title="Gestion asynchrone">
    GÃ©rer la rÃ©ception de signaux de maniÃ¨re asynchrone
  </Step>
  
  <Step title="Encodage/DÃ©codage">
    Convertir des caractÃ¨res en bits et vice versa
  </Step>
</Steps>

## Fonctionnement

### Principe de base

```
CLIENT                          SERVEUR
  |                                |
  |  -- SIGUSR1 (bit 0) -->        |
  |  -- SIGUSR2 (bit 1) -->        |
  |  -- SIGUSR1 (bit 0) -->        |
  |  ...  (8 bits = 1 char)        |
  |                                |
  |  <-- ACK (SIGUSR1) --          |
```

### Les signaux Unix

<AccordionGroup>
  <Accordion title="SIGUSR1">
    Signal utilisateur 1
    - Dans minitalk : reprÃ©sente le bit **0**
    - Peut Ãªtre envoyÃ© avec `kill(pid, SIGUSR1)`
  </Accordion>
  
  <Accordion title="SIGUSR2">
    Signal utilisateur 2
    - Dans minitalk : reprÃ©sente le bit **1**
    - Peut Ãªtre envoyÃ© avec `kill(pid, SIGUSR2)`
  </Accordion>
</AccordionGroup>

### Encodage d'un caractÃ¨re

Un caractÃ¨re est encodÃ© sur 8 bits :

```
CaractÃ¨re 'A' = 65 en dÃ©cimal = 01000001 en binaire

Transmission :
bit 7 (LSB) : 1 â†’ SIGUSR2
bit 6       : 0 â†’ SIGUSR1
bit 5       : 0 â†’ SIGUSR1
bit 4       : 0 â†’ SIGUSR1
bit 3       : 0 â†’ SIGUSR1
bit 2       : 0 â†’ SIGUSR1
bit 1       : 1 â†’ SIGUSR2
bit 0 (MSB) : 0 â†’ SIGUSR1
```

## Architecture du projet

```
minitalk/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ server.c          # Serveur
â”‚   â”œâ”€â”€ client.c          # Client
â”‚   â””â”€â”€ utils.c           # Fonctions utilitaires
â”œâ”€â”€ bonus/
â”‚   â”œâ”€â”€ server_bonus.c    # Serveur avec bonus
â”‚   â””â”€â”€ client_bonus.c    # Client avec bonus
â”œâ”€â”€ includes/
â”‚   â””â”€â”€ minitalk.h
â”œâ”€â”€ libft/
â””â”€â”€ Makefile
```

## Structures de donnÃ©es

```c
// Header minitalk.h
#ifndef MINITALK_H
# define MINITALK_H

# include <signal.h>
# include <unistd.h>
# include <stdlib.h>
# include "libft.h"

// Structure pour le serveur
typedef struct s_server
{
    int     bit_count;
    char    current_char;
}   t_server;

// Structure pour le client (bonus)
typedef struct s_client
{
    int     ack_received;
}   t_client;

// Fonctions
void    send_char(int pid, char c);
void    handle_signal_server(int sig, siginfo_t *info, void *context);
void    handle_signal_client(int sig);

#endif
```

## ImplÃ©mentation du serveur

### Main du serveur

```c
#include "minitalk.h"

t_server g_server;

int main(void)
{
    struct sigaction sa;
    
    // Initialiser la structure globale
    g_server.bit_count = 0;
    g_server.current_char = 0;
    
    // Afficher le PID
    ft_putstr_fd("Server PID: ", 1);
    ft_putnbr_fd(getpid(), 1);
    ft_putchar_fd('\n', 1);
    
    // Configurer sigaction
    sa.sa_sigaction = handle_signal_server;
    sa.sa_flags = SA_SIGINFO;  // Pour recevoir info sur l'Ã©metteur
    sigemptyset(&sa.sa_mask);
    
    // Enregistrer les handlers
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);
    
    // Boucle infinie
    while (1)
        pause();  // Attend un signal
    
    return (0);
}
```

### Handler de signaux

```c
void handle_signal_server(int sig, siginfo_t *info, void *context)
{
    (void)context;
    
    // DÃ©caler le caractÃ¨re actuel d'un bit vers la gauche
    g_server.current_char <<= 1;
    
    // Si SIGUSR2, mettre le bit Ã  1
    if (sig == SIGUSR2)
        g_server.current_char |= 1;
    
    // IncrÃ©menter le compteur de bits
    g_server.bit_count++;
    
    // Si on a reÃ§u 8 bits (un caractÃ¨re complet)
    if (g_server.bit_count == 8)
    {
        // Afficher le caractÃ¨re
        ft_putchar_fd(g_server.current_char, 1);
        
        // Si c'est '\0', fin du message
        if (g_server.current_char == '\0')
            ft_putchar_fd('\n', 1);
        
        // RÃ©initialiser
        g_server.bit_count = 0;
        g_server.current_char = 0;
    }
    
    // Bonus : envoyer un ACK au client
    kill(info->si_pid, SIGUSR1);
}
```

## ImplÃ©mentation du client

### Main du client

```c
#include "minitalk.h"

int main(int argc, char **argv)
{
    int     server_pid;
    char    *message;
    int     i;
    
    if (argc != 3)
    {
        ft_putendl_fd("Usage: ./client [server_pid] [message]", 2);
        return (1);
    }
    
    // RÃ©cupÃ©rer le PID du serveur
    server_pid = ft_atoi(argv[1]);
    message = argv[2];
    
    // VÃ©rifier le PID
    if (server_pid <= 0)
    {
        ft_putendl_fd("Error: Invalid PID", 2);
        return (1);
    }
    
    // Envoyer chaque caractÃ¨re
    i = 0;
    while (message[i])
    {
        send_char(server_pid, message[i]);
        i++;
    }
    
    // Envoyer le caractÃ¨re null de fin
    send_char(server_pid, '\0');
    
    return (0);
}
```

### Envoi d'un caractÃ¨re

```c
void send_char(int pid, char c)
{
    int bit;
    int i;
    
    i = 7;  // Commencer par le bit de poids fort
    while (i >= 0)
    {
        // Extraire le bit i
        bit = (c >> i) & 1;
        
        // Envoyer le signal correspondant
        if (bit == 0)
            kill(pid, SIGUSR1);
        else
            kill(pid, SIGUSR2);
        
        // Petite pause pour Ã©viter la perte de signaux
        usleep(100);  // 100 microsecondes
        
        i--;
    }
}
```

## Version bonus

### Ajout d'un ACK (acknowledgement)

Le client attend une confirmation du serveur aprÃ¨s chaque bit :

```c
// Variable globale pour le client
t_client g_client;

int main(int argc, char **argv)
{
    struct sigaction sa;
    int     server_pid;
    char    *message;
    int     i;
    
    if (argc != 3)
    {
        ft_putendl_fd("Usage: ./client [server_pid] [message]", 2);
        return (1);
    }
    
    // Configurer le handler pour recevoir les ACK
    sa.sa_handler = handle_signal_client;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);
    
    server_pid = ft_atoi(argv[1]);
    message = argv[2];
    
    // Envoyer le message
    i = 0;
    while (message[i])
    {
        send_char_with_ack(server_pid, message[i]);
        i++;
    }
    send_char_with_ack(server_pid, '\0');
    
    ft_putendl_fd("Message sent successfully!", 1);
    
    return (0);
}

void handle_signal_client(int sig)
{
    (void)sig;
    g_client.ack_received = 1;
}

void send_char_with_ack(int pid, char c)
{
    int bit;
    int i;
    
    i = 7;
    while (i >= 0)
    {
        bit = (c >> i) & 1;
        
        g_client.ack_received = 0;
        
        if (bit == 0)
            kill(pid, SIGUSR1);
        else
            kill(pid, SIGUSR2);
        
        // Attendre l'ACK
        while (!g_client.ack_received)
            usleep(10);
        
        i--;
    }
}
```

### Support Unicode (bonus)

Pour envoyer des caractÃ¨res Unicode, utiliser `wchar_t` :

```c
#include <wchar.h>
#include <locale.h>

void send_wchar(int pid, wchar_t wc)
{
    int bit;
    int i;
    
    // Un wchar_t fait 32 bits
    i = 31;
    while (i >= 0)
    {
        bit = (wc >> i) & 1;
        
        if (bit == 0)
            kill(pid, SIGUSR1);
        else
            kill(pid, SIGUSR2);
        
        usleep(100);
        i--;
    }
}

// Dans le serveur
void handle_signal_unicode(int sig, siginfo_t *info, void *context)
{
    static wchar_t  current_wchar = 0;
    static int      bit_count = 0;
    
    (void)context;
    
    current_wchar <<= 1;
    
    if (sig == SIGUSR2)
        current_wchar |= 1;
    
    bit_count++;
    
    if (bit_count == 32)  // 32 bits pour un wchar_t
    {
        ft_putwchar_fd(current_wchar, 1);
        
        if (current_wchar == L'\0')
            ft_putchar_fd('\n', 1);
        
        bit_count = 0;
        current_wchar = 0;
    }
    
    kill(info->si_pid, SIGUSR1);
}
```

## Compilation

```makefile
NAME = minitalk
SERVER = server
CLIENT = client
BONUS_SERVER = server_bonus
BONUS_CLIENT = client_bonus

CC = gcc
CFLAGS = -Wall -Wextra -Werror

SRCS_SERVER = src/server.c src/utils.c
SRCS_CLIENT = src/client.c src/utils.c
SRCS_BONUS_SERVER = bonus/server_bonus.c src/utils.c
SRCS_BONUS_CLIENT = bonus/client_bonus.c src/utils.c

OBJS_SERVER = $(SRCS_SERVER:.c=.o)
OBJS_CLIENT = $(SRCS_CLIENT:.c=.o)
OBJS_BONUS_SERVER = $(SRCS_BONUS_SERVER:.c=.o)
OBJS_BONUS_CLIENT = $(SRCS_BONUS_CLIENT:.c=.o)

LIBFT = libft/libft.a

all: $(SERVER) $(CLIENT)

$(SERVER): $(OBJS_SERVER) $(LIBFT)
	$(CC) $(CFLAGS) $(OBJS_SERVER) $(LIBFT) -o $(SERVER)

$(CLIENT): $(OBJS_CLIENT) $(LIBFT)
	$(CC) $(CFLAGS) $(OBJS_CLIENT) $(LIBFT) -o $(CLIENT)

$(BONUS_SERVER): $(OBJS_BONUS_SERVER) $(LIBFT)
	$(CC) $(CFLAGS) $(OBJS_BONUS_SERVER) $(LIBFT) -o $(BONUS_SERVER)

$(BONUS_CLIENT): $(OBJS_BONUS_CLIENT) $(LIBFT)
	$(CC) $(CFLAGS) $(OBJS_BONUS_CLIENT) $(LIBFT) -o $(BONUS_CLIENT)

$(LIBFT):
	make -C libft

bonus: $(BONUS_SERVER) $(BONUS_CLIENT)

clean:
	rm -f $(OBJS_SERVER) $(OBJS_CLIENT) $(OBJS_BONUS_SERVER) $(OBJS_BONUS_CLIENT)
	make -C libft clean

fclean: clean
	rm -f $(SERVER) $(CLIENT) $(BONUS_SERVER) $(BONUS_CLIENT)
	make -C libft fclean

re: fclean all

.PHONY: all bonus clean fclean re
```

## Utilisation

```bash
# Terminal 1 : Lancer le serveur
./server
# Output: Server PID: 12345

# Terminal 2 : Envoyer un message
./client 12345 "Hello 42!"
# Le serveur affiche: Hello 42!

# Envoyer un long message
./client 12345 "Lorem ipsum dolor sit amet, consectetur adipiscing elit."

# Envoyer des caractÃ¨res spÃ©ciaux
./client 12345 "Bonjour! ä½ å¥½ ğŸš€"  # (avec bonus Unicode)
```

## Tests

### Test basique

```bash
# Test simple
./server &
SERVER_PID=$!
./client $SERVER_PID "Test"
kill $SERVER_PID
```

### Test de performance

```bash
#!/bin/bash

# test_performance.sh

./server &
SERVER_PID=$!
sleep 1

# Tester avec diffÃ©rentes tailles
echo "Testing with short message..."
time ./client $SERVER_PID "Hello"

echo "Testing with medium message..."
time ./client $SERVER_PID "Lorem ipsum dolor sit amet"

echo "Testing with long message..."
LONG_MSG=$(python3 -c "print('A' * 1000)")
time ./client $SERVER_PID "$LONG_MSG"

kill $SERVER_PID
```

### Test de robustesse

```bash
#!/bin/bash

# test_stress.sh

./server &
SERVER_PID=$!
sleep 1

# Envoyer plusieurs messages rapidement
for i in {1..10}; do
    ./client $SERVER_PID "Message $i" &
done

wait

kill $SERVER_PID
```

## Fonctions autorisÃ©es

<Accordion title="Liste des fonctions autorisÃ©es">
  - `write`
  - `ft_printf` (ou Ã©quivalent)
  - `signal` ou `sigaction`
  - `sigemptyset`
  - `sigaddset`
  - `kill`
  - `getpid`
  - `malloc`
  - `free`
  - `pause`
  - `sleep`
  - `usleep`
  - `exit`
</Accordion>

## Concepts clÃ©s

### Signaux Unix

<AccordionGroup>
  <Accordion title="signal() vs sigaction()">
    **signal()** : Simple mais comportement non dÃ©fini
    ```c
    signal(SIGUSR1, handler);  // Ã€ Ã©viter
    ```
    
    **sigaction()** : RecommandÃ©, comportement dÃ©fini
    ```c
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);
    ```
  </Accordion>
  
  <Accordion title="SA_SIGINFO">
    Flag permettant de recevoir des informations sur l'Ã©metteur
    
    ```c
    struct sigaction sa;
    sa.sa_sigaction = handler_with_info;  // Pas sa_handler !
    sa.sa_flags = SA_SIGINFO;
    sigaction(SIGUSR1, &sa, NULL);
    
    void handler_with_info(int sig, siginfo_t *info, void *context)
    {
        pid_t sender_pid = info->si_pid;  // PID de l'Ã©metteur
        // ...
    }
    ```
  </Accordion>
  
  <Accordion title="pause() vs sleep()">
    **pause()** : Attend un signal (recommandÃ© pour le serveur)
    ```c
    while (1)
        pause();  // CPU idle
    ```
    
    **usleep()** : Attente active (pour le client)
    ```c
    usleep(100);  // 100 microsecondes
    ```
  </Accordion>
</AccordionGroup>

### Manipulation de bits

```c
// Extraire le bit i d'un nombre
int get_bit(char c, int i)
{
    return ((c >> i) & 1);
}

// Mettre le bit i Ã  1
char set_bit(char c, int i)
{
    return (c | (1 << i));
}

// Mettre le bit i Ã  0
char clear_bit(char c, int i)
{
    return (c & ~(1 << i));
}

// Inverser le bit i
char toggle_bit(char c, int i)
{
    return (c ^ (1 << i));
}

// DÃ©calage Ã  gauche
char shift_left(char c)
{
    return (c << 1);
}

// DÃ©calage Ã  droite
char shift_right(char c)
{
    return (c >> 1);
}
```

### Exemple de conversion bit par bit

```c
// Convertir un caractÃ¨re en binaire (affichage)
void print_bits(unsigned char c)
{
    int i;
    
    i = 7;
    while (i >= 0)
    {
        if ((c >> i) & 1)
            ft_putchar_fd('1', 1);
        else
            ft_putchar_fd('0', 1);
        i--;
    }
    ft_putchar_fd('\n', 1);
}

// Exemple d'utilisation
int main(void)
{
    print_bits('A');  // Output: 01000001
    print_bits('B');  // Output: 01000010
    print_bits('*');  // Output: 00101010
    return (0);
}
```

## Erreurs frÃ©quentes

<AccordionGroup>
  <Accordion title="Signaux perdus">
    **ProblÃ¨me** : Le serveur ne reÃ§oit pas tous les signaux si envoyÃ©s trop rapidement
    
    **Solution** : Ajouter un dÃ©lai entre chaque signal
    ```c
    kill(pid, SIGUSR1);
    usleep(100);  // Attendre 100 microsecondes
    ```
    
    Ou utiliser un systÃ¨me d'ACK (bonus)
  </Accordion>
  
  <Accordion title="Ordre des bits inversÃ©">
    **ProblÃ¨me** : Le message s'affiche mal
    
    **Solution** : VÃ©rifier l'ordre d'envoi (MSB ou LSB first)
    ```c
    // Envoyer du bit de poids fort au bit de poids faible
    i = 7;  // Commencer Ã  7
    while (i >= 0)
    {
        send_bit((c >> i) & 1);
        i--;
    }
    ```
  </Accordion>
  
  <Accordion title="Variables globales non rÃ©initialisÃ©es">
    **ProblÃ¨me** : Le serveur ne traite qu'un seul message
    
    **Solution** : RÃ©initialiser aprÃ¨s chaque caractÃ¨re
    ```c
    if (bit_count == 8)
    {
        ft_putchar_fd(current_char, 1);
        bit_count = 0;        // RÃ©initialiser
        current_char = 0;     // RÃ©initialiser
    }
    ```
  </Accordion>
  
  <Accordion title="PID invalide">
    **ProblÃ¨me** : Le client crash ou ne trouve pas le serveur
    
    **Solution** : Valider le PID
    ```c
    pid = ft_atoi(argv[1]);
    if (pid <= 0 || kill(pid, 0) == -1)
    {
        ft_putendl_fd("Error: Invalid PID", 2);
        return (1);
    }
    ```
  </Accordion>
  
  <Accordion title="Pas de gestion du '\0'">
    **ProblÃ¨me** : Le serveur ne sait pas quand le message se termine
    
    **Solution** : Toujours envoyer le '\0' Ã  la fin
    ```c
    // Dans le client
    while (message[i])
    {
        send_char(pid, message[i]);
        i++;
    }
    send_char(pid, '\0');  // Important !
    ```
  </Accordion>
</AccordionGroup>

## Optimisations

### RÃ©duire le dÃ©lai

```c
// Au lieu de usleep(100) constant
void send_char_optimized(int pid, char c)
{
    int bit;
    int i;
    
    i = 7;
    while (i >= 0)
    {
        bit = (c >> i) & 1;
        
        if (bit == 0)
            kill(pid, SIGUSR1);
        else
            kill(pid, SIGUSR2);
        
        // DÃ©lai adaptatif
        usleep(50);  // Plus rapide !
        
        i--;
    }
}
```

### Envoyer plusieurs bits par signal (avancÃ©)

```c
// Utiliser plus de 2 signaux (non standard)
// Attention : dÃ©passe les requirements du sujet
#define SIGNAL_BASE SIGRTMIN

void send_multi_bit(int pid, int value)
{
    kill(pid, SIGNAL_BASE + value);  // value entre 0 et 31
}
```

## AmÃ©liorations bonus avancÃ©es

### 1. Compression simple

```c
// Compresser les sÃ©quences rÃ©pÃ©titives
void send_compressed(int pid, char *msg)
{
    int i;
    int count;
    char current;
    
    i = 0;
    while (msg[i])
    {
        current = msg[i];
        count = 1;
        
        // Compter les rÃ©pÃ©titions
        while (msg[i + 1] == current && count < 255)
        {
            count++;
            i++;
        }
        
        // Si rÃ©pÃ©tÃ©, envoyer count puis char
        if (count > 3)
        {
            send_char(pid, 0xFF);  // Marqueur de compression
            send_char(pid, count);
            send_char(pid, current);
        }
        else
        {
            // Sinon envoyer normalement
            while (count--)
                send_char(pid, current);
        }
        i++;
    }
    send_char(pid, '\0');
}
```

### 2. Checksum pour vÃ©rifier l'intÃ©gritÃ©

```c
// Calculer un checksum simple
unsigned char calculate_checksum(char *msg)
{
    unsigned char sum;
    int i;
    
    sum = 0;
    i = 0;
    while (msg[i])
    {
        sum += msg[i];
        i++;
    }
    return (sum);
}

// Client envoie le message puis le checksum
void send_with_checksum(int pid, char *msg)
{
    unsigned char checksum;
    int i;
    
    i = 0;
    while (msg[i])
    {
        send_char(pid, msg[i]);
        i++;
    }
    send_char(pid, '\0');
    
    // Envoyer le checksum
    checksum = calculate_checksum(msg);
    send_char(pid, checksum);
}
```

### 3. Affichage de progression

```c
// Client affiche une barre de progression
void send_with_progress(int pid, char *msg)
{
    int total;
    int sent;
    int percent;
    int i;
    
    total = ft_strlen(msg);
    sent = 0;
    
    ft_putstr_fd("Sending: [", 1);
    
    i = 0;
    while (msg[i])
    {
        send_char(pid, msg[i]);
        sent++;
        
        // Calculer le pourcentage
        percent = (sent * 100) / total;
        
        // Afficher la progression
        ft_putstr_fd("\rSending: [", 1);
        display_progress_bar(percent);
        ft_putstr_fd("] ", 1);
        ft_putnbr_fd(percent, 1);
        ft_putstr_fd("%", 1);
        
        i++;
    }
    send_char(pid, '\0');
    ft_putendl_fd("\nDone!", 1);
}

void display_progress_bar(int percent)
{
    int i;
    int filled;
    
    filled = percent / 2;  // Barre de 50 caractÃ¨res
    i = 0;
    while (i < 50)
    {
        if (i < filled)
            ft_putchar_fd('=', 1);
        else
            ft_putchar_fd(' ', 1);
        i++;
    }
}
```

## Debugging

### Afficher les signaux reÃ§us

```c
void handle_signal_debug(int sig, siginfo_t *info, void *context)
{
    static int bit_count = 0;
    static char current_char = 0;
    
    (void)context;
    
    // Afficher le signal reÃ§u
    if (sig == SIGUSR1)
        ft_putstr_fd("0", 1);
    else
        ft_putstr_fd("1", 1);
    
    current_char <<= 1;
    if (sig == SIGUSR2)
        current_char |= 1;
    
    bit_count++;
    
    if (bit_count == 8)
    {
        ft_putstr_fd(" = '", 1);
        ft_putchar_fd(current_char, 1);
        ft_putendl_fd("'", 1);
        
        bit_count = 0;
        current_char = 0;
    }
    
    kill(info->si_pid, SIGUSR1);
}
```

### Tester la latence

```c
#include <sys/time.h>

double get_time_ms(void)
{
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    return (tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0);
}

void send_with_timing(int pid, char *msg)
{
    double start;
    double end;
    int len;
    
    start = get_time_ms();
    
    // Envoyer le message
    len = 0;
    while (msg[len])
    {
        send_char(pid, msg[len]);
        len++;
    }
    send_char(pid, '\0');
    
    end = get_time_ms();
    
    ft_putstr_fd("Sent ", 1);
    ft_putnbr_fd(len, 1);
    ft_putstr_fd(" chars in ", 1);
    ft_putnbr_fd((int)(end - start), 1);
    ft_putendl_fd(" ms", 1);
}
```

## Cas de test

<Tabs>
  <Tab title="Messages simples">
    ```bash
    ./client $PID "Hello"
    ./client $PID "42"
    ./client $PID "A"
    ./client $PID ""  # Message vide
    ```
  </Tab>
  
  <Tab title="CaractÃ¨res spÃ©ciaux">
    ```bash
    ./client $PID "Hello\nWorld"
    ./client $PID "Tab\there"
    ./client $PID "Quote: \"test\""
    ./client $PID "Backslash: \\"
    ```
  </Tab>
  
  <Tab title="Messages longs">
    ```bash
    # GÃ©nÃ©rer un message de 1000 caractÃ¨res
    MSG=$(python3 -c "print('A' * 1000)")
    ./client $PID "$MSG"
    
    # Message de 10000 caractÃ¨res
    MSG=$(python3 -c "print('X' * 10000)")
    ./client $PID "$MSG"
    ```
  </Tab>
  
  <Tab title="Unicode (bonus)">
    ```bash
    ./client $PID "Ã‰mojis: ğŸš€ ğŸ‰ â¤ï¸"
    ./client $PID "ä¸­æ–‡æµ‹è¯•"
    ./client $PID "FranÃ§ais: cafÃ©, crÃ¨me"
    ./client $PID "Math: Ï€ â‰ˆ 3.14"
    ```
  </Tab>
  
  <Tab title="Test de stress">
    ```bash
    # Envoyer plusieurs messages en parallÃ¨le
    for i in {1..10}; do
        ./client $PID "Message $i" &
    done
    wait
    ```
  </Tab>
</Tabs>

## Conseils

<Tip>
**Commencez simple** : Faites d'abord fonctionner la version basique avant d'ajouter les bonus.
</Tip>

<Tip>
**Testez bit par bit** : Utilisez `print_bits()` pour vÃ©rifier que les bits sont corrects.
</Tip>

<Tip>
**Augmentez progressivement** : Testez d'abord avec un seul caractÃ¨re, puis un mot, puis des phrases.
</Tip>

<Warning>
**Attention aux variables globales** : Utilisez-les avec prÃ©caution, rÃ©initialisez-les correctement.
</Warning>

<Warning>
**usleep() minimal** : Ne descendez pas en dessous de 50 microsecondes, sinon risque de perte de signaux.
</Warning>

## Ressources

<CardGroup cols={2}>
  <Card title="man signal" icon="book">
    ```bash
    man 2 signal
    man 2 sigaction
    man 2 kill
    ```
    Documentation des signaux Unix
  </Card>
  
  <Card title="Signaux Unix" icon="wave-pulse" href="https://www.gnu.org/software/libc/manual/html_node/Signal-Handling.html">
    Guide complet sur les signaux
  </Card>
  
  <Card title="Bit Manipulation" icon="binary" href="https://www.tutorialspoint.com/cprogramming/c_bitwise_operators.htm">
    OpÃ©rateurs de manipulation de bits
  </Card>
  
  <Card title="IPC" icon="arrows-left-right" href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">
    Communication inter-processus
  </Card>
</CardGroup>

## SchÃ©ma de fonctionnement

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CLIENT                               â”‚
â”‚                                                              â”‚
â”‚  Message: "Hi"                                              â”‚
â”‚                                                              â”‚
â”‚  'H' = 72 = 01001000                                        â”‚
â”‚                                                              â”‚
â”‚  Envoi bit par bit:                                         â”‚
â”‚  0 â†’ SIGUSR1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  1 â†’ SIGUSR2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  0 â†’ SIGUSR1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”        â”‚
â”‚  0 â†’ SIGUSR1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”     â”‚
â”‚  1 â†’ SIGUSR2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”  â”‚
â”‚  0 â†’ SIGUSR1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”â”‚
â”‚  0 â†’ SIGUSR1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”‚â”‚
â”‚  0 â†’ SIGUSR1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”‚â”‚
â”‚                                         â”‚       â”‚  â”‚  â”‚  â”‚ â”‚â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”‚â”‚
                                          â†“       â†“  â†“  â†“  â†“ â†“â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SERVEUR                              â”‚
â”‚                                                              â”‚
â”‚  RÃ©ception:                                                 â”‚
â”‚  bit_count = 0, char = 00000000                            â”‚
â”‚                                                              â”‚
â”‚  SIGUSR1 â†’ char = 00000000 (bit 0)                         â”‚
â”‚  SIGUSR2 â†’ char = 00000001 (bit 1)                         â”‚
â”‚  SIGUSR1 â†’ char = 00000010 (bit 0)                         â”‚
â”‚  SIGUSR1 â†’ char = 00000100 (bit 0)                         â”‚
â”‚  SIGUSR2 â†’ char = 00001001 (bit 1)                         â”‚
â”‚  SIGUSR1 â†’ char = 00010010 (bit 0)                         â”‚
â”‚  SIGUSR1 â†’ char = 00100100 (bit 0)                         â”‚
â”‚  SIGUSR1 â†’ char = 01001000 (bit 0)                         â”‚
â”‚                                                              â”‚
â”‚  bit_count = 8 â†’ Afficher: 'H' (72)                        â”‚
â”‚  RÃ©initialiser: bit_count = 0, char = 0                    â”‚
â”‚                                                              â”‚
â”‚  ... RÃ©pÃ©ter pour 'i' ...                                   â”‚
â”‚  ... RÃ©pÃ©ter pour '\0' ...                                  â”‚
â”‚                                                              â”‚
â”‚  Output final: "Hi"                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Conclusion

Minitalk est un excellent projet pour comprendre :
- La communication inter-processus
- Les signaux Unix
- La manipulation de bits
- La programmation asynchrone

<Check>
Une fois maÃ®trisÃ©, vous aurez acquis des bases solides en communication systÃ¨me qui vous serviront pour les projets futurs !
</Check>

<Note>
Les concepts appris ici (signaux, IPC, manipulation de bits) sont fondamentaux en programmation systÃ¨me et vous serviront tout au long de votre carriÃ¨re.
</Note>

<Tip>
**Conseil final** : Prenez le temps de bien comprendre comment les signaux fonctionnent avant de coder. Un bon schÃ©ma vaut mieux que 1000 lignes de code !
</Tip>